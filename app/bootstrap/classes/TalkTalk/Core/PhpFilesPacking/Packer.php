<?php

namespace TalkTalk\Core\PhpFilesPacking;

use TalkTalk\Core\Application;

class Packer {

    public static function compileAppFiles(Application $app)
    {
        $appIncludedFiles = array_filter(
            get_included_files(),
            function ($filePath) use ($app) {
               return (
                   false !== strpos($filePath, '/classes/') &&
                   false === strpos($filePath, $app->vars['app.vendors.path']) &&
                   false === strpos($filePath, 'composer') &&
                   false === strpos($filePath, __DIR__)
               );
            }
        );

        self::compileFiles($appIncludedFiles, $app->vars['app.var.cache.path'] . '/php-packs/app.pack.php');
    }

    public static function compileAppVendors(Application $app)
    {
        $vendorsIncludedFiles = array_filter(
            get_included_files(),
            function ($filePath) use ($app) {
               return (
                   0 === strpos($filePath, $app->vars['app.vendors.path']) &&
                   false === strpos($filePath, 'composer') &&
                   false === strpos($filePath, 'autoload.php') &&
                   false === strpos(basename($filePath), 'function')
               );
            }
        );

        self::compileFiles($vendorsIncludedFiles, $app->vars['app.var.cache.path'] . '/php-packs/vendors.pack.php');
    }

    public static function compileFiles(array $phpInputFilesPaths, $targetFilePath, $removeCommentsAndWhitespaces = false)
    {
        $targetFile = fopen($targetFilePath, 'w');

        fwrite(
            $targetFile,
            '<?php' . PHP_EOL . PHP_EOL .
            '/* Generated by ' . __METHOD__ . ' at ' . date('Y-md- H:i:s') . ' */' .
            PHP_EOL . PHP_EOL
        );

        foreach ($phpInputFilesPaths as $phpFilePath) {

            $phpFileContent = file_get_contents($phpFilePath);

            // First php opening tag removal
            if ('<?php' === substr($phpFileContent, 0, 5)) {
                $phpFileContent = PHP_EOL . "/* @begin \"$phpFilePath\" */" . PHP_EOL . substr($phpFileContent, 5);
            }

            // Namespace management
            $namespaceName = null;
            $phpFileContent = preg_replace_callback(
                '~namespace\s+([a-z][a-z0-9_\\\\]+)\s*;~i',
                function (array $matches) use (&$namespaceName)
                {
                  $namespaceName = $matches[1];
                  return 'namespace ' . $namespaceName. ' {' . PHP_EOL ;
                },
                $phpFileContent
            );
            if (null !== $namespaceName) {
                // Close the namespace with a bracket
                $phpFileContent .= PHP_EOL . '} //end namespace "' . $namespaceName . '"' . PHP_EOL ;
            } elseif (!preg_match('~^\s*namespace\s+~m', $phpFileContent)) {
                // No namespace? Let's enclose this PHP file content in a root one!
                $phpFileContent = 'namespace {' . PHP_EOL . $phpFileContent . PHP_EOL . '} //end namespace' . PHP_EOL ;
            }

            // __DIR__ quick'n'dirty management
            $phpFileContent = str_replace('__DIR__', '\'' . dirname($phpFilePath) . '\'', $phpFileContent);

            // A small "packing" comment is appended to the file
            $phpFileContent .= PHP_EOL . "/* @end \"$phpFilePath\" */" . PHP_EOL . PHP_EOL;

            fwrite($targetFile, $phpFileContent);

        }

        fwrite(
            $targetFile,
            PHP_EOL . '/** ' . PHP_EOL .
            count($phpInputFilesPaths) . ' PHP files packed in this file:'. PHP_EOL .
            print_r($phpInputFilesPaths, true) . PHP_EOL .
            '**/' . PHP_EOL
        );

        fclose($targetFile);

        if ($removeCommentsAndWhitespaces) {
            file_put_contents($targetFilePath, php_strip_whitespace($targetFilePath));
        }
    }

}